<script setup lang="ts">
import { computed, defineAsyncComponent, inject, onMounted, ref, Ref, watch } from 'vue';
import { useI18n } from 'vue-i18n';
import { useRouter } from 'vue-router';
import { AsyncComponent, NoData, notification, Spin } from '@xcan-angus/vue-ui';
import { appContext, download, enumUtils, http, PageQuery, TESTER, utils } from '@xcan-angus/infra';
import { isEqual } from 'lodash-es';
import { modules, task } from '@/api/tester';
import { TaskSprintPermission, TaskStatus } from '@/enums/enums';
import { getCurrentPage } from '@/utils/utils';
import { TaskInfo } from '../../types';
import { ActionMenuItem, TaskViewMode, travelTreeData } from '../types';
// eslint-disable-next-line import/no-absolute-path
import Template from '/file/Import_Task_Template.xlsx?url';

/**
 * Component props interface for task list page
 */
type Props = {
  sprintId: string;
  sprintName: string;
  projectId: string;
  projectName: string;
  userInfo: { id: string; };
  appInfo: { id: string; };
  notify: string;
}

// COMPONENT PROPS
const props = withDefaults(defineProps<Props>(), {
  sprintId: undefined,
  sprintName: undefined,
  projectId: undefined,
  userInfo: undefined,
  appInfo: undefined,
  notify: undefined
});

// ASYNC COMPONENTS
const StatisticsPanel = defineAsyncComponent(() => import('@/views/task/task/list/statistics/index.vue'));
const SearchPanel = defineAsyncComponent(() => import('@/views/task/task/list/SearchPanel.vue'));
const Edit = defineAsyncComponent(() => import('@/views/task/task/list/task/Edit.vue'));
const Move = defineAsyncComponent(() => import('@/views/task/task/list/task/Move.vue'));
const Upload = defineAsyncComponent(() => import('@/views/task/task/list/task/Upload.vue'));
const FlowChart = defineAsyncComponent(() => import('@/views/task/task/list/task/FlowChart.vue'));

const ModuleTree = defineAsyncComponent(() => import('./ModuleTree.vue'));
const KanbanView = defineAsyncComponent(() => import('@/views/task/task/list/task/kanban/index.vue'));
const GanttView = defineAsyncComponent(() => import('@/views/task/task/list/task/gantt/index.vue'));
const TableView = defineAsyncComponent(() => import('@/views/task/task/list/task/table/index.vue'));
const FlatView = defineAsyncComponent(() => import('@/views/task/task/list/task/flat/index.vue'));

// COMPOSABLES & INJECTIONS
const { t } = useI18n();
const router = useRouter();

const deleteTabPane = inject<(value: string[]) => void>('deleteTabPane');
const isAdmin = computed(() => appContext.isAdmin());
const proTypeShowMap = inject<Ref<{[key: string]: boolean}>>('proTypeShowMap', ref({ showTask: true, showBackLog: true, showMeeting: true, showSprint: true, showTasStatistics: true }));

// REACTIVE STATE
const statisticsRefreshNotify = ref<string>(); // Statistics panel refresh notification
const listRefreshNotify = ref<string>(); // Task list refresh notification

const kanbanGroupKey = ref<'none' | 'assigneeName' | 'lastModifiedByName' | 'taskType'>('none');
const kanbanOrderBy = ref<'priority' | 'deadlineDate' | 'createdByName' | 'assigneeName'>();
const kanbanOrderSort = ref<PageQuery.OrderSort>();

const isStatisticsCollapsed = ref(true); // Initially collapsed, will auto-expand after initialization if not manually collapsed
const currentViewMode = ref<TaskViewMode>(TaskViewMode.flat);
const isModuleGroupEnabled = ref(false);
const isFlowChartVisible = ref(false);
const isExporting = ref(false);

const isDataLoaded = ref(false);
const isLoading = ref(false);
const currentOrderBy = ref<string>();
const currentOrderSort = ref<PageQuery.OrderSort>();
const searchFilters = ref<{ key: string; op: string; value: boolean | string | string[]; }[]>([]);
const paginationInfo = ref<{ current: number; pageSize: number; total: number; }>({ current: 1, pageSize: 10, total: 0 });
const taskListData = ref<TaskInfo[]>([]);
const sprintPermissionsCache = ref<Map<string, TaskSprintPermission[]>>(new Map());

const selectedTaskName = ref<string>();
const selectedTaskSprintId = ref<string>();
const selectedTaskId = ref<string>();
const isTaskModalVisible = ref(false);
const isMoveModalVisible = ref(false);
const isUploadModalVisible = ref(false);

const searchSprintId = ref<string>();
const currentEditTaskData = ref<TaskInfo>(); // Task data for edit modal

const selectedTaskIds = ref<string[]>([]); // Batch selected task IDs

const previousSearchParams = ref<{[key:string]:any}>();

/**
 * Builds API parameters for task list requests
 * @returns Formatted parameters for API calls
 */
const buildApiParameters = () => {
  const params: {
    backlog?: boolean,
    projectId: string;
    pageNo: number;
    pageSize: number;
    filters?: { key: string; op: string; value: boolean | string | string[]; }[];
    orderBy?: string;
    orderSort?: PageQuery.OrderSort;
  } = {
    backlog: proTypeShowMap.value.showBackLog ? false : undefined,
    projectId: props.projectId,
    pageNo: paginationInfo.value.current,
    pageSize: paginationInfo.value.pageSize
  };

  if (searchFilters.value.length) {
    params.filters = searchFilters.value;
  }

  if (currentOrderSort.value) {
    params.orderBy = currentOrderBy.value;
    params.orderSort = currentOrderSort.value;
  }
  return params;
};

/**
 * Loads task list data from API
 */
const loadTaskListData = async () => {
  if (!currentViewMode.value || ![TaskViewMode.flat, TaskViewMode.table].includes(currentViewMode.value)) {
    return;
  }

  isLoading.value = false;
  const params = buildApiParameters();
  const [error, response] = await task.getTaskList({ ...params, moduleId: currentModuleId.value });
  isLoading.value = false;
  isDataLoaded.value = true;
  if (error) {
    return false;
  }

  const data = (response?.data || { total: '0', list: [] }) as { total: string; list: TaskInfo[] };
  const totalCount = +data.total;
  paginationInfo.value.total = totalCount;

  const pageNumber = +params.pageNo;
  const pageSize = +params.pageSize;
  const taskListItems = (data.list || []);
  const processedTaskList: TaskInfo[] = [];
  const sprintIdSet = new Set<string>();

  for (let i = 0, len = taskListItems.length; i < len; i++) {
    const taskItem = taskListItems[i];
    const taskParams = {
      ...params,
      taskId: taskItem.id,
      pageNo: (pageNumber - 1) * pageSize + i + 1,
      pageSize: 1,
      total: totalCount
    };

    processedTaskList.push({
      ...taskItem,
      linkUrl: '/task#task?' + http.getURLSearchParams(taskParams, true)
    });

    sprintIdSet.add(taskItem.sprintId);
  }

  taskListData.value = processedTaskList;

  // Reset selected tasks if search conditions changed (excluding page number)
  if (previousSearchParams.value) {
    delete previousSearchParams.value.pageNo;
    delete params.pageNo;
    if (!isEqual(previousSearchParams.value, params)) {
      selectedTaskIds.value = [];
    }
  }

  previousSearchParams.value = params;

  // Load sprint permissions
  sprintPermissionsCache.value.clear();
  const sprintIds = Array.from(sprintIdSet);
  // Admin users have all permissions, no need to load permissions
  if (!isAdmin.value && proTypeShowMap.value.showSprint) {
    for (let i = 0, len = sprintIds.length; i < len; i++) {
      const sprintId = sprintIds[i];
      if (sprintId) {
        const [permissionError, permissionResponse] = await loadSprintPermissions(sprintId);
        if (!permissionError) {
          const permissions = (permissionResponse?.data || []).map(item => item.value);
          sprintPermissionsCache.value.set(sprintId, permissions);
        }
      }
    }
  } else {
    for (let i = 0, len = sprintIds.length; i < len; i++) {
      const sprintId = sprintIds[i];
      sprintPermissionsCache.value.set(sprintId, enumUtils.getEnumValues(TaskSprintPermission));
    }
  }
};

/**
 * Loads sprint permissions for a specific sprint
 * @param sprintId - Sprint ID to load permissions for
 * @returns Promise with permission data
 */
const loadSprintPermissions = async (sprintId: string) => {
  const params = {
    admin: true
  };
  return await task.getUserSprintAuth(sprintId, props.userInfo?.id, params);
};

/**
 * Loads module tree data
 * @param keywords - Optional search keywords for filtering modules
 */
const loadModuleTreeData = async (keywords?: string) => {
  const [error, { data }] = await modules.getModuleTree({
    projectId: props.projectId,
    filters: keywords
      ? [{
          value: keywords,
          op: 'MATCH',
          key: 'name'
        }]
      : []
  });
  if (error) {
    return;
  }
  moduleTreeData.value = [{ name: t('task.list.noModuleTask'), id: '-1' }, ...travelTreeData(data || [])];
  if (currentModuleId.value && keywords && !moduleTreeData.value.find(item => item.id === currentModuleId.value)) {
    currentModuleId.value = '';
  }
};

/**
 * Handles search panel filter changes
 * @param filterData - New filter data from search panel
 */
const handleSearchPanelChange = (filterData: { key: string; op: string; value: boolean | string | string[]; }[]) => {
  searchFilters.value = filterData;
  paginationInfo.value.current = 1;
  loadTaskListData();
};

/**
 * Handles table sorting and pagination changes
 * @param paginationData - Pagination data
 * @param sorter - Sorting configuration
 */
const handleTableChange = ({ current, pageSize }: { current: number; pageSize: number; },
  sorter: { orderBy: string; orderSort: PageQuery.OrderSort }) => {
  paginationInfo.value.current = current;
  paginationInfo.value.pageSize = pageSize;

  currentOrderBy.value = sorter.orderBy;
  currentOrderSort.value = sorter.orderSort;

  loadTaskListData();
};

/**
 * Handles pagination changes
 * @param paginationData - New pagination data
 */
const handlePaginationChange = (paginationData: { current: number; pageSize: number; }) => {
  paginationInfo.value.current = paginationData.current;
  paginationInfo.value.pageSize = paginationData.pageSize;
  loadTaskListData();
};

/**
 * Handles task creation by opening create modal
 */
const handleTaskCreation = () => {
  // Set current sprint from search filters
  const sprintFilter = searchFilters.value.find(filter => filter.key === 'sprintId');
  searchSprintId.value = sprintFilter?.value as string;
  isTaskModalVisible.value = true;
};

/**
 * Opens upload task modal
 */
const openUploadTaskModal = () => {
  isUploadModalVisible.value = true;
};

/**
 * Handles upload task modal cancellation
 */
const handleUploadTaskCancel = () => {
  isUploadModalVisible.value = false;
};

/**
 * Handles upload task completion
 */
const handleUploadTaskComplete = () => {
  loadTaskListData();
};

/**
 * Handles template export for task import
 */
const handleExportTemplate = async () => {
  const downloadLink = document.createElement('a');
  downloadLink.style.display = 'none';
  downloadLink.href = Template;
  downloadLink.download = 'Import_Task_Template.xlsx';
  document.body.appendChild(downloadLink);
  downloadLink.click();
  document.body.removeChild(downloadLink);
};

/**
 * Handles task list export
 */
const handleTaskExport = async () => {
  if (isExporting.value) {
    notification.info(t('task.messages.exportingInProgress'));
    return;
  }

  isExporting.value = true;
  const exportUrl = `${TESTER}/task/export?` + http.getURLSearchParams({ projectId: props.projectId, filters: searchFilters.value }, true);
  await download(exportUrl);
  isExporting.value = false;
};

/**
 * Handles refresh notifications
 */
const handleRefreshChange = () => {
  statisticsRefreshNotify.value = utils.uuid();
};

/**
 * Handles task split completion
 */
const handleTaskSplitComplete = () => {
  statisticsRefreshNotify.value = utils.uuid();
  loadTaskListData();
};

/**
 * Handles view mode changes
 * @param newViewMode - New view mode to switch to
 */
const handleViewModeChange = (newViewMode: TaskViewMode) => {
  if ([TaskViewMode.kanban, TaskViewMode.gantt].includes(currentViewMode.value) &&
    [TaskViewMode.table, TaskViewMode.flat].includes(newViewMode)) {
    currentViewMode.value = newViewMode;
    paginationInfo.value.current = 1;
    loadTaskListData();
  }

  currentViewMode.value = newViewMode;
};

/**
 * Handles task edit by opening edit modal
 * @param taskId - ID of task to edit
 */
const handleTaskEdit = (taskId: string) => {
  selectedTaskId.value = taskId;
  handleTaskCreation();
};

/**
 * Handles task edit completion
 * @param taskData - Updated task data
 * @param isNewTask - Whether this is a new task being added
 */
const handleTaskEditComplete = (taskData: TaskInfo, isNewTask = false) => {
  if (isNewTask) {
    loadTaskListData();
    return;
  }

  if (taskData) {
    updateTaskListData(taskData);
  }
};

/**
 * Handles task deletion
 * @param taskId - ID of task to delete
 */
const handleTaskDeletion = (taskId: string) => {
  paginationInfo.value.current = getCurrentPage(paginationInfo.value.current, paginationInfo.value.pageSize, paginationInfo.value.total);
  loadTaskListData();
  if (typeof deleteTabPane === 'function') {
    deleteTabPane([taskId]);
  }
};

/**
 * Handles task move by opening move modal
 * @param taskData - Task data to move
 */
const handleTaskMove = (taskData: TaskInfo) => {
  selectedTaskSprintId.value = taskData.sprintId;
  selectedTaskName.value = taskData.name;
  selectedTaskId.value = taskData.id;
  isMoveModalVisible.value = true;
};

/**
 * Handles task move completion
 */
const handleTaskMoveComplete = () => {
  selectedTaskSprintId.value = undefined;
  selectedTaskName.value = undefined;
  selectedTaskId.value = undefined;
  paginationInfo.value.current = getCurrentPage(paginationInfo.value.current, paginationInfo.value.pageSize, paginationInfo.value.total);
  loadTaskListData();
};

/**
 * Handles batch actions on selected tasks
 * @param actionKey - Action to perform
 * @param taskIds - Array of task IDs to perform action on
 */
const handleBatchAction = (actionKey: 'cancel' | 'delete' | 'follow' | 'favourite' | 'move', taskIds: string[]) => {
  switch (actionKey) {
    case 'cancel':
      handleBatchCancel(taskIds);
      break;
    case 'delete':
      handleBatchDelete(taskIds);
      break;
    case 'favourite':
      handleBatchFavourite();
      break;
    case 'move':
      handleBatchMove(taskIds);
      break;
    default:
      break;
  }
};

/**
 * Handles batch task cancellation
 * @param taskIds - Array of task IDs to cancel
 */
const handleBatchCancel = async (taskIds: string[]) => {
  // If no status filter, refresh list directly
  const hasStatusCondition = searchFilters.value.find(filter => filter.key === 'status');
  if (hasStatusCondition) {
    handleBatchActionComplete(taskIds);
    return;
  }

  await loadTaskListData();
};

/**
 * Handles batch task deletion
 * @param taskIds - Array of task IDs to delete
 */
const handleBatchDelete = async (taskIds: string[]) => {
  handleBatchActionComplete(taskIds);
};

/**
 * Handles batch task favourite toggle
 */
const handleBatchFavourite = async () => {
  // Update current list data
  await loadTaskListData();
};

/**
 * Handles batch task move
 * @param taskIds - Array of task IDs to move
 */
const handleBatchMove = (taskIds: string[]) => {
  // If no sprint filter, refresh list directly
  const hasSprintCondition = searchFilters.value.find(filter => filter.key === 'sprintId');
  if (hasSprintCondition) {
    handleBatchActionComplete(taskIds);
    return;
  }

  loadTaskListData();
};

/**
 * Handles batch action completion with pagination adjustment
 * @param taskIds - Array of task IDs that were processed
 */
const handleBatchActionComplete = (taskIds: string[]) => {
  const { current, pageSize, total } = paginationInfo.value;
  const totalPages = Math.ceil(total / pageSize);
  const remainder = total % pageSize;

  const deleteCount = taskIds.length;
  const deletePages = Math.floor(deleteCount / pageSize);
  const deleteRemainder = deleteCount % pageSize;

  if ((deleteRemainder === 0 || remainder === 0) || (deleteRemainder < remainder)) {
    if (current + deletePages <= totalPages) {
      // Notify list refresh
      listRefreshNotify.value = utils.uuid();
      // Notify statistics panel refresh
      statisticsRefreshNotify.value = utils.uuid();
      return;
    }

    paginationInfo.value.current = current - (current + deletePages - totalPages) || 1;
    // Notify list refresh
    listRefreshNotify.value = utils.uuid();
    // Notify statistics panel refresh
    statisticsRefreshNotify.value = utils.uuid();
    return;
  }

  if (deleteRemainder >= remainder) {
    if (current + deletePages + 1 <= totalPages) {
      // Notify list refresh
      listRefreshNotify.value = utils.uuid();
      // Notify statistics panel refresh
      statisticsRefreshNotify.value = utils.uuid();
      return;
    }

    // Notify list refresh
    listRefreshNotify.value = utils.uuid();
    // Notify statistics panel refresh
    statisticsRefreshNotify.value = utils.uuid();
  }
};

/**
 * Updates task data in the list
 * @param taskData - Updated task data
 */
const updateTaskListData = (taskData: Partial<TaskInfo>) => {
  if (taskData) {
    const taskIndex = taskListData.value.findIndex(item => item.id === taskData.id);
    if (taskListData.value[taskIndex]) {
      taskListData.value[taskIndex] = { ...taskListData.value[taskIndex], ...taskData };
      currentEditTaskData.value = taskListData.value[taskIndex];
    }
  }
};

// MODULE MANAGEMENT
const moduleTreeData = ref([{ name: t('task.list.noModuleTask'), id: '-1' }]);
const currentModuleId = ref();

/**
 * Component mounted lifecycle hook
 * Initializes module tree and sets up watchers
 */
onMounted(async () => {
  await router.replace('/task#task');

  await loadModuleTreeData();

  watch(() => props.projectId, () => {
    currentModuleId.value = '';
    loadModuleTreeData();
  });

  watch(() => listRefreshNotify.value, (newNotificationValue) => {
    if (newNotificationValue === undefined || newNotificationValue === null || newNotificationValue === '') {
      return;
    }

    loadTaskListData();
  }, { immediate: true });

  watch(() => isModuleGroupEnabled.value, () => {
    if (isModuleGroupEnabled.value) {
      currentModuleId.value = '';
    } else {
      currentModuleId.value = undefined;
    }
  });

  watch(() => currentModuleId.value, () => {
    // Notify list refresh
    listRefreshNotify.value = utils.uuid();
    // Notify statistics panel refresh
    statisticsRefreshNotify.value = utils.uuid();
  });
});

/**
 * Computed property for task action menu items
 * Generates context menu items based on task status and user permissions
 */
const taskActionMenuItems = computed<Map<string, ActionMenuItem[]>>(() => {
  const menuItemsMap = new Map<string, ActionMenuItem[]>();
  const taskList = taskListData.value || [];

  for (let i = 0, len = taskList.length; i < len; i++) {
    const taskItem = taskList[i];
    const taskStatus = taskItem.status?.value;
    const sprintId = taskItem.sprintId;
    const sprintAuth = taskItem.sprintAuth;

    const permissions = sprintPermissionsCache.value.get(sprintId) || [];
    const { currentAssociateType, confirmerId, assigneeId, createdBy } = taskItem;

    const currentUserId = props.userInfo?.id;
    const isCurrentUserAdmin = !!currentAssociateType?.map(associateType => associateType.value).includes('SYS_ADMIN' || 'APP_ADMIN');
    const isCurrentUserConfirmer = confirmerId === currentUserId;
    const isCurrentUserAssignee = assigneeId === currentUserId;

    const menuItems: ActionMenuItem[] = [
      {
        name: t('task.actions.edit'),
        key: 'edit',
        icon: 'icon-shuxie',
        disabled: !isCurrentUserAdmin && !permissions.includes(TaskSprintPermission.MODIFY_TASK) && sprintAuth,
        hide: true
      },
      {
        name: t('task.actions.delete'),
        key: 'delete',
        icon: 'icon-qingchu',
        disabled: !isCurrentUserAdmin && !permissions.includes(TaskSprintPermission.DELETE_TASK) && sprintAuth,
        hide: true
      },
      {
        name: t('task.actions.split'),
        key: 'split',
        icon: 'icon-guanlianziyuan',
        disabled: !isCurrentUserAdmin && !permissions.includes(TaskSprintPermission.MODIFY_TASK) && sprintAuth,
        hide: true
      }
    ];

    if (taskStatus === TaskStatus.PENDING) {
      menuItems.push({
        name: t('task.actions.start'),
        key: 'start',
        icon: 'icon-kaishi',
        disabled: !isCurrentUserAdmin && !isCurrentUserAssignee,
        hide: false
      });
    }

    if (taskStatus === TaskStatus.IN_PROGRESS) {
      menuItems.push({
        name: t('task.actions.complete'),
        key: 'processed',
        icon: 'icon-yichuli',
        disabled: !isCurrentUserAdmin && !isCurrentUserAssignee,
        hide: false
      });
    }

    if (taskStatus === TaskStatus.CONFIRMING) {
      menuItems.push({
        name: t('task.actions.confirmComplete'),
        key: TaskStatus.COMPLETED,
        icon: 'icon-yiwancheng',
        disabled: !isCurrentUserAdmin && !isCurrentUserConfirmer,
        hide: false
      });

      menuItems.push({
        name: t('task.actions.confirmIncomplete'),
        key: 'uncompleted',
        icon: 'icon-shibaiyuanyin',
        disabled: !isCurrentUserAdmin && !isCurrentUserConfirmer,
        hide: false
      });
    }

    if (taskStatus === TaskStatus.CANCELED || taskStatus === TaskStatus.COMPLETED) {
      menuItems.push({
        name: t('task.actions.reopen'),
        key: 'reopen',
        icon: 'icon-zhongxindakaiceshirenwu',
        disabled: !isCurrentUserAdmin && !permissions.includes(TaskStatus.REOPEN_TASK) && !isCurrentUserAssignee,
        hide: false,
        tip: t('task.tips.reopenTip')
      });

      menuItems.push({
        name: t('task.actions.restart'),
        key: 'restart',
        icon: 'icon-zhongxinkaishiceshi',
        disabled: !isCurrentUserAdmin && !permissions.includes(TaskStatus.RESTART_TASK),
        hide: false,
        tip: t('task.tips.restartTip')
      });
    }

    if (taskStatus !== TaskStatus.CANCELED && taskStatus !== TaskStatus.COMPLETED) {
      menuItems.push({
        name: t('task.actions.cancel'),
        key: 'cancel',
        icon: 'icon-zhongzhi2',
        disabled: !isCurrentUserAdmin && !permissions.includes(TaskSprintPermission.MODIFY_TASK) && sprintAuth,
        hide: false
      });
    }

    const { favourite, follow } = taskItem;
    if (favourite) {
      menuItems.push({
        name: t('task.actions.unfavorite'),
        key: 'cancelFavourite',
        icon: 'icon-quxiaoshoucang',
        disabled: false,
        hide: false
      });
    } else {
      menuItems.push({
        name: t('task.actions.favorite'),
        key: 'favourite',
        icon: 'icon-yishoucang',
        disabled: false,
        hide: false
      });
    }

    if (follow) {
      menuItems.push({
        name: t('task.actions.unfollow'),
        key: 'cancelFollow',
        icon: 'icon-quxiaoguanzhu',
        disabled: false,
        hide: false
      });
    } else {
      menuItems.push({
        name: t('task.actions.follow'),
        key: 'follow',
        icon: 'icon-yiguanzhu',
        disabled: false,
        hide: false
      });
    }

    menuItems.push({
      name: t('task.actions.move'),
      key: 'move',
      icon: 'icon-yidong',
      disabled: !isCurrentUserAdmin && !permissions.includes(TaskSprintPermission.MODIFY_TASK) && sprintAuth,
      hide: false
    });

    menuItems.push({
      name: t('task.copyLink'),
      key: 'copyLink',
      icon: 'icon-fuzhi',
      disabled: false,
      hide: false
    });

    menuItemsMap.set(taskItem.id, menuItems);
  }

  return menuItemsMap;
});

/**
 * Computed property for statistics panel parameters
 * Builds parameters for statistics API calls
 */
const statisticsParameters = computed(() => {
  const parameters = { };
  if (proTypeShowMap.value.showBackLog) {
    parameters.backlog = false;
  }
  if (searchFilters.value.length) {
    parameters.filters = searchFilters.value;
  }
  if (currentModuleId.value) {
    parameters.moduleId = currentModuleId.value;
  }
  return parameters;
});
</script>

<template>
  <Spin :spinning="isLoading" class="flex flex-col pl-3.5 pt-3.5 h-full overflow-y-auto overflow-x-hidden">
    <StatisticsPanel
      :collapse="isStatisticsCollapsed"
      :params="statisticsParameters"
      :notify="statisticsRefreshNotify"
      :userInfo="props.userInfo"
      :appInfo="props.appInfo"
      :projectId="props.projectId"
      :class="{ 'mb-3': !isStatisticsCollapsed }"
      class="pr-5" />

    <div class="flex h-full">
      <div class="flex-shrink-0 h-full overflow-hidden pb-3 bg-gray-1 text-3" :class="{'w-65 mr-2': isModuleGroupEnabled , 'w-0': !isModuleGroupEnabled}">
        <ModuleTree
          v-model:moduleId="currentModuleId"
          :projectId="props.projectId"
          :projectName="props.projectName"
          :dataList="moduleTreeData"
          @loadData="loadModuleTreeData" />
      </div>
      <div class="flex-1 flex flex-col overflow-x-hidden">
        <SearchPanel
          v-model:collapse="isStatisticsCollapsed"
          v-model:visible="isFlowChartVisible"
          v-model:moduleFlag="isModuleGroupEnabled"
          v-model:groupKey="kanbanGroupKey"
          v-model:orderBy="kanbanOrderBy"
          v-model:orderSort="kanbanOrderSort"
          :viewMode="currentViewMode"
          :userInfo="props.userInfo"
          :appInfo="props.appInfo"
          :projectId="props.projectId"
          :sprintId="props.sprintId"
          :sprintName="props.sprintName"
          class="mb-1.5 pr-5"
          @change="handleSearchPanelChange"
          @add="handleTaskCreation"
          @export="handleTaskExport"
          @uploadTask="openUploadTaskModal"
          @exportTemplate="handleExportTemplate"
          @viewModeChange="handleViewModeChange" />

        <KanbanView
          v-if="currentViewMode === TaskViewMode.kanban"
          v-model:loading="isLoading"
          v-model:moduleId="currentModuleId"
          :groupKey="kanbanGroupKey"
          :orderBy="kanbanOrderBy"
          :orderSort="kanbanOrderSort"
          :filters="searchFilters"
          :projectId="props.projectId"
          :userInfo="props.userInfo"
          :appInfo="props.appInfo"
          class="pr-5"
          @refreshChange="handleRefreshChange" />

        <GanttView
          v-else-if="currentViewMode === TaskViewMode.gantt"
          v-model:loading="isLoading"
          v-model:moduleId="currentModuleId"
          :filters="searchFilters"
          :projectId="props.projectId"
          :userInfo="props.userInfo"
          :appInfo="props.appInfo"
          class="pr-5" />

        <template v-else-if="isDataLoaded">
          <div v-if="!taskListData.length" class="flex-1 pr-5 h-full flex items-center justify-center">
            <NoData />
          </div>

          <TableView
            v-else-if="currentViewMode === TaskViewMode.table"
            v-model:loading="isLoading"
            v-model:selectedIds="selectedTaskIds"
            :projectId="props.projectId"
            :dataSource="taskListData"
            :pagination="paginationInfo"
            :menuItemsMap="taskActionMenuItems"
            class="pr-5"
            @tableChange="handleTableChange"
            @edit="handleTaskEdit"
            @move="handleTaskMove"
            @delete="handleTaskDeletion"
            @dataChange="updateTaskListData"
            @batchAction="handleBatchAction"
            @refreshChange="handleRefreshChange" />

          <FlatView
            v-else-if="currentViewMode === TaskViewMode.flat"
            v-model:loading="isLoading"
            v-model:selectedIds="selectedTaskIds"
            :projectId="props.projectId"
            :userInfo="props.userInfo"
            :appInfo="props.appInfo"
            :dataSource="taskListData"
            :editTaskData="currentEditTaskData"
            :pagination="paginationInfo"
            :menuItemsMap="taskActionMenuItems"
            :loaded="isDataLoaded"
            @edit="handleTaskEdit"
            @move="handleTaskMove"
            @delete="handleTaskDeletion"
            @dataChange="updateTaskListData"
            @paginationChange="handlePaginationChange"
            @batchAction="handleBatchAction"
            @refreshChange="handleRefreshChange"
            @splitOk="handleTaskSplitComplete" />
        </template>
      </div>
    </div>

    <AsyncComponent :visible="isTaskModalVisible">
      <Edit
        v-model:visible="isTaskModalVisible"
        v-model:taskId="selectedTaskId"
        :sprintId="searchSprintId"
        :projectId="props.projectId"
        :userInfo="props.userInfo"
        :appInfo="props.appInfo"
        :moduleId="currentModuleId === '-1' ? undefined : currentModuleId"
        @ok="handleTaskEditComplete" />
    </AsyncComponent>

    <AsyncComponent :visible="isFlowChartVisible">
      <FlowChart v-model:visible="isFlowChartVisible" />
    </AsyncComponent>

    <AsyncComponent :visible="isMoveModalVisible">
      <Move
        v-model:visible="isMoveModalVisible"
        :sprintId="selectedTaskSprintId"
        :taskIds="selectedTaskId"
        :taskName="selectedTaskName"
        :projectId="props.projectId"
        @ok="handleTaskMoveComplete" />
    </AsyncComponent>
    <AsyncComponent :visible="isUploadModalVisible">
      <Upload
        v-model:visible="isUploadModalVisible"
        :downloadTemplate="handleExportTemplate"
        @cancel="handleUploadTaskCancel"
        @ok="handleUploadTaskComplete" />
    </AsyncComponent>
  </Spin>
</template>
